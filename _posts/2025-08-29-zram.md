---
title: Understanding zram
category: tech
tags: [memory, kernel, storage, swap, block]
---

title:  Understanding zram

* TOC
{:toc}


# ZRAM: Compressed RAM Block Device - Detailed Implementation Analysis (From AI)

## Overview & Principle

  ZRAM is a compressed RAM-based block device that creates virtual block devices backed by compressed memory instead of physical
  storage. It's primarily used for:

  - Swap space: More efficient than traditional disk-based swap
  - High-speed storage: Temporary storage with RAM-like performance
  - Memory expansion: Effective memory increase through compression

## Core Architecture

### Main Data Structures

- struct zram (zram_drv.h:103-141)

  The main device structure containing:

```
  struct zram {
      struct zram_table_entry *table;    // Page table for metadata
      struct zs_pool *mem_pool;         // Memory pool for compressed data
      struct zcomp *comps[ZRAM_MAX_COMPS]; // Compression backends (up to 4)
      struct zcomp_params params[ZRAM_MAX_COMPS]; // Compression parameters
      struct gendisk *disk;             // Block device representation
      struct rw_semaphore init_lock;    // Initialization synchronization
      unsigned long limit_pages;       // Memory usage limit
      struct zram_stats stats;          // Performance statistics
      u64 disksize;                    // Virtual disk size
      const char *comp_algs[ZRAM_MAX_COMPS]; // Compression algorithm names
      s8 num_active_comps;             // Number of active compressors
      bool claim;                      // Device claim status
      // Optional writeback and tracking features...
  };
```

- struct zram_table_entry (zram_drv.h:66-73)

  Per-page metadata entry:

```
  struct zram_table_entry {
      unsigned long handle;    // Handle to compressed data in memory pool
      unsigned long flags;     // Page flags (compressed size + status bits)
      ktime_t ac_time;        // Access time (if tracking enabled)
      struct lockdep_map dep_map; // Lockdep debugging
  };
```

Flags encoding (zram_drv.h:39):
    - Lower ZRAM_FLAG_SHIFT bits: Compressed object size
    - Higher bits: Page flags (SAME, HUGE, IDLE, etc.)

### Compression Framework

- Multi-Algorithm Support (zcomp.h)

  ZRAM supports multiple compression algorithms simultaneously:

```
  struct zcomp {
      struct zcomp_strm __percpu *stream; // Per-CPU compression streams
      const struct zcomp_ops *ops;        // Algorithm operations
      struct zcomp_params *params;        // Algorithm parameters
      struct hlist_node node;             // CPU hotplug management
  };
```

Available Algorithms:

    - LZO/LZO-RLE: Fast compression, good for general use

    - LZ4/LZ4HC: Fastest decompression, moderate compression

    - ZSTD: Best compression ratio, higher CPU usage

    - DEFLATE: Standard compression

    - 842: Hardware-accelerated on some platforms

- Per-CPU Streams (zcomp.h:40-47)

  Each CPU has dedicated compression context to avoid contention:

```
  struct zcomp_strm {
      struct mutex lock;      // Stream synchronization
      void *buffer;          // Compression working buffer
      void *local_copy;      // Local memory copy
      struct zcomp_ctx ctx;  // Algorithm-specific context
  };
```

### Detailed Implementation

- I/O Path Implementation

Block Device Operations (zram_drv.c)

Entry Point: zram_submit_bio()

```
  static void zram_submit_bio(struct bio *bio) {
      struct zram *zram = bio->bi_bdev->bd_disk->private_data;

      switch (bio_op(bio)) {
      case REQ_OP_READ:  zram_bio_read(zram, bio); break;
      case REQ_OP_WRITE: zram_bio_write(zram, bio); break;
      case REQ_OP_DISCARD: zram_bio_discard(zram, bio); break;
      }
  }
```

- Read Operation Flow:

```
  1. zram_bio_read(): Iterates through bio segments
  u32 index = iter.bi_sector >> SECTORS_PER_PAGE_SHIFT;
  u32 offset = (iter.bi_sector & (SECTORS_PER_PAGE - 1)) << SECTOR_SHIFT;
  2. zram_bvec_read(): Reads individual page
  3. zram_read_from_zspool(): Decompresses data from memory pool
  4. Copy to user buffer: Transfer decompressed data
```

- Write Operation Flow:

```
  1. zram_bio_write(): Processes write bio
  2. zram_bvec_write(): Handles individual page write
  3. Compression: Compress page using selected algorithm
  4. Memory allocation: Allocate space in zsmalloc pool
  5. Storage: Store compressed data and update metadata
```

#### Memory Management

- ZSmalloc Integration

ZRAM uses zsmalloc for efficient storage of variable-sized compressed objects:

    - Class-based allocation: Objects grouped by size classes

    - High memory utilization: Minimizes fragmentation

    - Compaction support: Can migrate objects to reduce fragmentation

- Page Classification:

```
enum zram_pageflags {
    ZRAM_SAME,           // All bytes identical (stores single value)
    ZRAM_HUGE,           // Incompressible (stored uncompressed)
    ZRAM_IDLE,           // Not accessed recently
    ZRAM_INCOMPRESSIBLE, // Failed compression with all algorithms
    ZRAM_WB,             // Written back to backing device
};
```

- Special Optimizations:

    - Same-filled pages: Pages with identical bytes store only one value

    - Huge pages: Pages that don't compress well stored uncompressed

    - Incompressible detection: Avoid repeated compression attempts

#### Advanced Features

-  Write-back Support (CONFIG_ZRAM_WRITEBACK)

Can writeback cold pages to slower storage:

```
  #ifdef CONFIG_ZRAM_WRITEBACK
  struct file *backing_dev;      // Backing storage file
  struct block_device *bdev;     // Block device for writeback
  unsigned long *bitmap;         // Track written-back pages
  unsigned long nr_pages;        // Number of pages in backing storage
  #endif
```

-  Memory Tracking (CONFIG_ZRAM_MEMORY_TRACKING)

Provides detailed memory usage statistics via debugfs.

Idle Page Detection

Tracks page access patterns to identify candidates for writeback or compression optimization.

## Performance Characteristics

- Memory Efficiency:

    - Compression ratios: Typically 2:1 to 4:1 depending on data and algorithm

    - Metadata overhead: ~16 bytes per 4KB page

    - Memory savings: Significant for swap workloads

- Performance Trade-offs:

    - CPU vs Memory: Uses CPU cycles to save memory

    - Algorithm selection: Fast (LZ4) vs high compression (ZSTD)

    - Concurrency: Per-CPU streams eliminate lock contention

##  Use Cases:

- Swap replacement: Much faster than disk-based swap

- Tmpfs backing: Compressed temporary file systems

- Container optimization: Reduce memory footprint

- Embedded systems: Expand effective memory capacity

##  Configuration & Tuning

Runtime Configuration (/sys/block/zramX/):

- disksize: Set virtual disk size

- comp_algorithm: Choose compression algorithm

- mem_limit: Limit memory usage

- idle: Mark pages as idle for writeback

- backing_dev: Configure writeback storage

## Statistics Monitoring (zram_stats):

```
  struct zram_stats {
      atomic64_t compr_data_size;  // Total compressed size
      atomic64_t failed_reads;     // Read failures
      atomic64_t failed_writes;    // Write failures  
      atomic64_t same_pages;       // Same-filled pages
      atomic64_t huge_pages;       // Incompressible pages
      atomic64_t pages_stored;     // Currently stored pages
      // ... additional counters
  };
```

ZRAM provides an efficient way to extend system memory through compression, offering
significant memory savings with reasonable CPU overhead, making it ideal for
memory-constrained environments and high-performance swap scenarios.


# Questions

## zram compression

### Does zram support deduplication?

