---
title: io-uring notes
category: Tech
tags: [linux kernel, io_uring, IO]
---

* TOC
{:toc}


io-uring notes

# **io-uring uses**

## IORING_SETUP_DEFER_TASKRUN

### motivation

- [initial patchset](https://lore.kernel.org/io-uring/20220815130911.988014-1-dylany@fb.com/)

- defer async work until user space calls io_uring_enter with the GETEVENTS flag

- [avoid to overflow CQ queue](https://lore.kernel.org/io-uring/ab2d2f5c-0e76-44a2-8a7e-6f9edcfa5a92@gmail.com/)

- improve network workload perf

### usage

- require IORING_SETUP_SINGLE_ISSUER

For DEFER_TASKRUN we require the completion task to be the same as the

submission task. This implies that there is only one submitter, so enforce that.



# **io-uring internal**

## io_kiocb double completion & link advancing in case of io-wq

1) request may be complete via task_work: 1st completetion

>
> ```
> static void io_req_complete_post(struct io_kiocb *req, unsigned issue_flags)
>     ...
> 	/*
> 	 * Handle special CQ sync cases via task_work. DEFER_TASKRUN requires
> 	 * the submitter task context, IOPOLL protects with uring_lock.
> 	 */
> 	if (ctx->task_complete || (ctx->flags & IORING_SETUP_IOPOLL)) {
> 		req->io_task_work.func = io_req_task_complete;
> 		io_req_task_work_add(req);
> 		return;
> 	}
>     ...
> ```

2) request completed via io_free_req(): final completion

> ```
> struct io_wq_work *io_wq_free_work(struct io_wq_work *work)
> {
> 	struct io_kiocb *req = container_of(work, struct io_kiocb, work);
> 	struct io_kiocb *nxt = NULL;
> 
> 	if (req_ref_put_and_test(req)) {
> 		if (req->flags & IO_REQ_LINK_FLAGS)
> 			nxt = io_req_find_next(req);
> 		io_free_req(req);
> 	}
> 	return nxt ? &nxt->work : NULL;
> }
> ```

Then the result is that the same request appears two times in `__io_submit_flush_completions`

BTW, for io-wq, link advancing is done in `io_wq_free_work()` or `io_queue_next()` from
`io_free_batch_list`, and it depends on where the refcount drops to zero in the
two code paths.

